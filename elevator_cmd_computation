def calculate_priority(cmd_elevator, cmd_floor, current_state, last_state):
    int_elevator = []
    int_floor = []
    
    for i in range(len(cmd_elevator)):
        int_elevator.append(int(cmd_elevator[i][1]))    
    for i in range(len(cmd_floor)):
        int_floor.append(int(cmd_floor[i][0]))

    if not cmd_A:
        if cmd_floor:
            next_cmd = cmd_floor[0]
            return next_cmd
        else:
            return
    else:
        if (not current_state) or (not last_state) or (not -1 < current_state < 4):
            next_cmd = cmd_elevator[0]
            return next_cmd
        else:
            direction = last_state - current_state
            valid_cmd = [0] * len(cmd_elevator)
            if direction < 0:
                for x in range(len(cmd_elevator)):
                    if int_elevator[x] > current_state:
                        valid_cmd[x] = 1
                try:
                    next_cmd_idx = [idx for idx in range(len(cmd_elevator)) if valid_cmd[idx] == 1][0]
                    next_cmd = cmd_elevator[next_cmd_idx]
                    return next_cmd
                except sum(valid_cmd) == 0:
                    next_cmd = cmd_elevator[0]
                    return next_cmd
                    
            elif direction > 0:
                for x in range(len(cmd_elevator)):
                    if int_elevator[x] < current_state:
                        valid_cmd[x] = 1
                try:
                    next_cmd_idx = [idx for idx in range(len(cmd_elevator)) if valid_cmd[idx] == 1][0]
                    next_cmd = cmd_elevator[next_cmd_idx]
                    return next_cmd
                except sum(valid_cmd) == 0:
                    next_cmd = cmd_elevator[0]
                    return next_cmd                  
            else:
                next_cmd = min(x for x in range(len(valid_cmd)) - current_state)
                return next_cmd





    
current_state = [0, 0] #startpoint (needed for calculate_priority)
last_state = [0, 0] 
cmd_floor = []
cmd_A = []
cmd_B = []


usrinput = input('--> ')
commands = usrinput.split(',')
#evaluate correctness of entry data

for cnt in range(len(commands)):
    if  'r' in commands[cnt][1] or 'h' in commands[cnt][1]:
        cmd_floor.append(commands[cnt])
    elif ('A') in commands[cnt][0]:
        cmd_A.append(commands[cnt])
    elif ('B') in commands[cnt][0]:
        cmd_B.append(commands[cnt])



#implement waiting of 1-3 rounds
    
#make a loop with recursive calling of functions and updating of last_state, current_state
next_A = calculate_priority(cmd_A, cmd_floor, current_state[0], last_state[0])
#pop task from A and B
next_B = calculate_priority(cmd_B, cmd_floor, current_state[1], last_state[1])
#pop task from A and B

